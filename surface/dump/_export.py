""" Export out data as stub files """

import os
import collections

from surface.dump._representation import Class, Module

STUB_HEADER = "# Automatically generated stub file. Generated by 'surface' (pip install surface)\n\n"

def export_stubs(representation, directory):
    # type: (Dict[str, Dict[str, BaseWrapper]], str) -> None 
    """ Build a stubfile structure from the provided information """
    # Filter out imported modules into their own structured files
    representation = filter_representation(representation)

    # Build skeleton files, to later fill with content
    files = build_skeleton_files(representation, directory)

    # Fill in the content of a file
    for path, contents in representation.items():
        with open(files[path], "a") as fh:
            fh.write(build_content(contents))


def build_content(contents):
    # type: (Dict[str, BaseWrapper]) -> str
    """ Generate the content within the stub file """

    indent = "    "

    # TODO: get dependency information (eg import requirements for types, location imports for classes)
    # TODO: let each representation build its string, but in order.
    # TODO: handle indentation
    body_block = []
    indent_stack = []
    # Walk from shortest to longest
    for name in sorted(contents):
        # If we leave an indented block, drop down
        if indent_stack and not name.startswith(indent_stack[-1]):
            indent_stack.pop()
        
        node = contents[name]
        body_block.append(node.export(indent * len(indent_stack), name))

        # If we are a class, enter an indented block
        if isinstance(node, Class):
            indent_stack.append(name + ".") 
    
    return "\n\n".join(body_block)


def build_skeleton_files(paths, directory):
    # type: (Collection[str], str) -> Dict[str, str]
    """ Build files out. Empty at this stage. Ready to be filled with stub content """
    structures = {}
    for path in sorted(paths, reverse=True):
        if path in structures:
            continue
        
        sections = path.split(".")
        for i in range(1, len(sections)):
            subsection = sections[:i]
            key = ".".join(subsection)
            if key in structures:
                continue
            package = os.path.join(directory, *subsection)
            init = os.path.join(package, "__init__.pyi")
            if not os.path.isfile(init):
                os.mkdir(package)
                with open(init, "w") as fh:
                    fh.write(STUB_HEADER)
            structures[key] = init
        module = os.path.join(directory, *sections) + ".pyi"
        if not os.path.isfile(module):
            with open(module, "w") as fh:
                fh.write(STUB_HEADER)
        structures[path] = module
    return structures


def filter_representation(representation):
    # type: (Dict[str, Dict[str, BaseWrapper]]) -> Dict[str, Dict[str, BaseWrapper]]
    """ Pull imported modules into their own file """
    new_representation = collections.defaultdict(dict)
    for path, contents in representation.items():
        module_map = {}
        # We need to read this shortest to longest.
        # Least specific to most.
        for qualname in sorted(contents):
            node = contents[qualname]
            new_path = path
            new_qualname = qualname

            # If a value belongs to an imported module, move it into there
            # We need to read this from longest to shortest (most specific to least)
            for prefix in sorted(module_map, reverse=True):
                if qualname.startswith(prefix):
                    print(">", qualname)
                    new_path = module_map[prefix]
                    new_qualname = qualname[len(prefix)+1:]
                    break

            # If an imported module is found. Mark it, and we'll create a new stub for it
            if isinstance(node, Module):
                module_map[qualname] = node.get_name()

            new_representation[new_path][new_qualname] = node
        
    
    return new_representation