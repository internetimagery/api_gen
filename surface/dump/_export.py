""" Export out data as stub files """


import os
import collections

from surface.dump._representation import Class, Module

STUB_HEADER = "# Automatically generated stub file. Generated by 'surface' (pip install surface)\n\n"


def export_stubs(representation, directory):
    # type: (Dict[str, Dict[str, BaseWrapper]], str) -> None 
    """ Build a stubfile structure from the provided information """
    # Filter out imported modules into their own structured files
    representation = filter_representation(representation)

    # Build skeleton files, to later fill with content
    files = build_skeleton_files(representation, directory)

    # Fill in the content of a file
    for path, contents in representation.items():
        with open(files[path], "a") as fh:
            fh.write(build_content(contents))


def build_content(contents):
    # type: (Dict[str, BaseWrapper]) -> str
    """ Generate the content within the stub file """

    import_block = []
    body_block = []
    indent_stack = []
    # Walk from shortest to longest
    for name in sorted(contents):
        # If we leave an indented block, drop down
        if indent_stack and not name.startswith(indent_stack[-1]):
            indent_stack.pop()
        
        node = contents[name]
        import_block.extend(node.get_imports(name))
        body_block.append(node.get_body(len(indent_stack), name))

        # If we are a class, enter an indented block
        if isinstance(node, Class):
            indent_stack.append(name + ".") 
    
    return "{}\n\n{}".format(
        build_import_block(import_block),
        build_body_block(body_block),
    )


def build_body_block(body_block):
    # type: (List[str]) -> str
    return "\n\n".join(
        body
        for body in body_block
        if body
    )

def build_import_block(import_block):
    # type: (List[Import]) -> str
    if not import_block:
        return ""

    imports = set()
    from_imports = collections.defaultdict(set)

    # Sort import types
    for import_ in import_block:
        if import_.name:
            # from package import module as _module
            from_imports[import_.path].add(import_)
        else:
            # import package.module
            imports.add(import_)
    
    # Build out our block
    import_lines = []
    alias = "{} as {}".format
    for import_ in sorted(imports):
        import_lines.append("import {}".format(alias(import_.path, import_.alias) if import_.alias else import_.path))
    for path in sorted(from_imports):
        import_line = (
            alias(import_.name, import_.alias) if import_.alias else import_.name
            for import_ in from_imports[path]
        )
        import_lines.append("from {} import {}".format(
            path, ", ".join(sorted(import_line))
        ))
    return "\n".join(import_lines)


def build_skeleton_files(paths, directory):
    # type: (Collection[str], str) -> Dict[str, str]
    """ Build files out. Empty at this stage. Ready to be filled with stub content """
    structures = {}
    for path in sorted(paths, reverse=True):
        if path in structures:
            continue
        
        sections = path.split(".")
        for i in range(1, len(sections)):
            subsection = sections[:i]
            key = ".".join(subsection)
            if key in structures:
                continue
            package = os.path.join(directory, *subsection)
            init = os.path.join(package, "__init__.pyi")
            if not os.path.isfile(init):
                os.mkdir(package)
                with open(init, "w") as fh:
                    fh.write(STUB_HEADER)
            structures[key] = init
        module = os.path.join(directory, *sections) + ".pyi"
        if not os.path.isfile(module):
            with open(module, "w") as fh:
                fh.write(STUB_HEADER)
        structures[path] = module
    return structures


def filter_representation(representation):
    # type: (Dict[str, Dict[str, BaseWrapper]]) -> Dict[str, Dict[str, BaseWrapper]]
    """ Pull imported modules into their own file """
    new_representation = collections.defaultdict(dict)
    for path, contents in representation.items():
        module_map = {}
        # We need to read this shortest to longest.
        # Least specific to most.
        for qualname in sorted(contents):
            node = contents[qualname]
            new_path = path
            new_qualname = qualname

            # If a value belongs to an imported module, move it into there
            # We need to read this from longest to shortest (most specific to least)
            for prefix in sorted(module_map, reverse=True):
                if qualname.startswith(prefix):
                    new_path = module_map[prefix]
                    new_qualname = qualname[len(prefix)+1:]
                    break

            # If an imported module is found. Mark it, and we'll create a new stub for it
            if isinstance(node, Module):
                module_map[qualname] = node.get_name()

            new_representation[new_path][new_qualname] = node
        
    
    return new_representation